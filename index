
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Litigation Jackson</title>
    <style>
        body {
            font-family: monospace;
            background-color: #000;
            color: #0f0;
            margin: 0;
            padding: 20px;
            max-width: 800px;
            margin: auto;
        }
        #title-screen {
            text-align: center;
            margin-top: 100px;
        }
        #game {
            display: none;
        }
        #scoreboard {
            border: 1px solid #0f0;
            padding: 10px;
            margin-bottom: 20px;
        }
        #text {
            border: 1px solid #0f0;
            padding: 10px;
            margin-bottom: 20px;
            height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        #choices {
            text-align: center;
        }
        button {
            background-color: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0f0;
            color: #000;
        }
        .learn-more {
            cursor: pointer;
            color: #ff0;
            text-decoration: underline;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="title-screen">
        <h1>Litigation Jackson</h1>
        <p>A retro adventure in contract negotiation!</p>
        <button onclick="startGame()">Start New Game</button>
        <button onclick="restartGame()" id="restart-btn" style="display:none;">Restart</button>
    </div>
    <div id="game">
        <div id="scoreboard"></div>
        <div id="text"></div>
        <div id="choices"></div>
    </div>

    <script>
        // Data structures for modularity
        // To expand: Add more objects to these arrays for new clauses, events, projects, etc.
        const projects = [
            "Transmission rebuild for Western Utilities",
            "Helicopter patrol contract for Midwest Power",
            "Turnkey substation EPC for Eastern Grid"
            // Add more project names here for variety
        ];

        const customerTypes = [
            { name: "Risk-averse government entity", pushbackChance: 0.2, walkAwayChance: 0.1 },
            { name: "Cost-focused utility", pushbackChance: 0.5, walkAwayChance: 0.3 },
            { name: "Aggressive private developer", pushbackChance: 0.8, walkAwayChance: 0.5 }
            // Add more customer types with adjusted probabilities
        ];

        const clauses = [
            {
                name: "Indemnification",
                redline: "Customer proposes open-ended indemnification for all claims, including third-party negligence.",
                options: {
                    accept: {
                        risk: 20, profit: -10, relation: 10,
                        exp: "Accepting this exposes your company to unlimited liability, potentially leading to financial ruin from unforeseen claims.",
                        bp: "Never accept open-ended indemnification; always limit to your company's negligence and cap damages."
                    },
                    counter: {
                        risk: 5, profit: 0, relation: 5,
                        exp: "Countering balances the clause, reducing exposure while showing willingness to negotiate.",
                        bp: "Propose mutual indemnification limited to direct negligence."
                    },
                    reject: {
                        risk: -10, profit: 10, relation: -15,
                        exp: "Rejecting protects your company but may strain the relationship if the customer sees it as inflexible.",
                        bp: "Reject only if you can justify with industry standards; offer alternatives."
                    }
                }
            },
            {
                name: "Limitation of Liability",
                redline: "Customer removes all limitations on liability, making damages unlimited.",
                options: {
                    accept: {
                        risk: 25, profit: -15, relation: 10,
                        exp: "Unlimited liability can bankrupt your firm over a single incident.",
                        bp: "Always limit liability to the contract value or a multiple thereof."
                    },
                    counter: {
                        risk: 10, profit: -5, relation: 5,
                        exp: "A countered limit protects assets while maintaining dialogue.",
                        bp: "Counter with liability capped at 1-2x contract value."
                    },
                    reject: {
                        risk: -15, profit: 15, relation: -20,
                        exp: "Full rejection safeguards finances but risks deal breakdown.",
                        bp: "Reject if unlimited; reference insurance limits."
                    }
                }
            },
            {
                name: "Payment Terms / Retainage",
                redline: "Customer proposes 20% retainage held until 6 months post-completion.",
                options: {
                    accept: {
                        risk: 10, profit: -20, relation: 15,
                        exp: "High retainage ties up cash flow, impacting profitability.",
                        bp: "Payment retention should not exceed 10% unless project duration > 12 months."
                    },
                    counter: {
                        risk: 0, profit: -5, relation: 10,
                        exp: "Countering for lower retainage improves cash flow without much risk.",
                        bp: "Counter with 5-10% retainage released upon substantial completion."
                    },
                    reject: {
                        risk: -5, profit: 20, relation: -10,
                        exp: "Rejecting ensures better margins but may annoy cost-sensitive customers.",
                        bp: "Reject high retainage; tie to milestones."
                    }
                }
            },
            {
                name: "Change Orders",
                redline: "Customer requires pre-approval for all change orders with no markup allowed.",
                options: {
                    accept: {
                        risk: 15, profit: -15, relation: 10,
                        exp: "No markup on changes erodes profits on scope creep.",
                        bp: "Insist on reasonable markup (10-15%) for changes."
                    },
                    counter: {
                        risk: 5, profit: 0, relation: 5,
                        exp: "Countering allows fair compensation for extra work.",
                        bp: "Counter with time-and-materials billing for changes."
                    },
                    reject: {
                        risk: -10, profit: 15, relation: -15,
                        exp: "Rejection prevents unprofitable work but could halt negotiations.",
                        bp: "Reject no-markup clauses; reference cost recovery."
                    }
                }
            },
            {
                name: "Force Majeure",
                redline: "Customer narrows force majeure to exclude supply chain issues.",
                options: {
                    accept: {
                        risk: 20, profit: -10, relation: 10,
                        exp: "Narrow definition leaves you liable for uncontrollable events like delays.",
                        bp: "Broaden to include pandemics, strikes, and supply disruptions."
                    },
                    counter: {
                        risk: 5, profit: 0, relation: 5,
                        exp: "Countering adds protections without confrontation.",
                        bp: "Counter with standard broad language."
                    },
                    reject: {
                        risk: -10, profit: 10, relation: -15,
                        exp: "Rejection ensures coverage but may signal distrust.",
                        bp: "Reject narrow definitions; cite examples."
                    }
                }
            }
            // Add more clauses here in the same format to expand the game
        ];

        const randomEvents = [
            {
                text: "Customer Legal cites industry standard language, pressuring you to concede.",
                effect: { risk: 5, profit: -5, relation: -5 }
            },
            {
                text: "Your legal team warns that acceptance creates downstream risk — think twice!",
                effect: { risk: 10, relation: 5 }
            },
            {
                text: "VP of Operations calls — project needs to start next week. Time pressure mounts.",
                effect: { profit: -10, relation: -5 }
            },
            {
                text: "Customer agrees to your language if you drop another clause. A trade-off appears.",
                effect: { risk: -5, profit: 5, relation: 10 }
            }
            // Add more events here for more randomness
        ];

        const outcomes = [
            { title: "Hero of the Legal Frontier", condition: (scores) => scores.risk < 50 && scores.profit > 50 && scores.relation > 50, desc: "Balanced negotiation — you win the deal without undue risk!" },
            { title: "Paper Pusher", condition: (scores) => scores.profit < 40, desc: "You gave away too much; profitability suffers." },
            { title: "The Redline Reaper", condition: (scores) => scores.relation < 40, desc: "Too aggressive — the customer walks away." },
            { title: "Litigation Jackson!", condition: (scores) => scores.risk > 70, desc: "Ignored risks; a lawsuit is on the horizon." }
            // Default to Hero if none match, but adjust conditions as needed
        ];

        // Game state variables
        let scores = { risk: 0, profit: 100, relation: 100 }; // Start with low risk (0 good), high profit/relation (100 good)
        let currentProject;
        let currentCustomer;
        let selectedClauses = [];
        let currentClauseIndex = 0;
        let transcript = [];
        let gameOver = false;

        function startGame() {
            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('game').style.display = 'block';
            document.getElementById('restart-btn').style.display = 'inline';
            initGame();
        }

        function restartGame() {
            location.reload(); // Simple restart
        }

        function initGame() {
            scores = { risk: 0, profit: 100, relation: 100 };
            currentProject = projects[Math.floor(Math.random() * projects.length)];
            currentCustomer = customerTypes[Math.floor(Math.random() * customerTypes.length)];
            selectedClauses = shuffleArray(clauses).slice(0, Math.floor(Math.random() * 3) + 3); // 3-5 clauses
            currentClauseIndex = 0;
            transcript = [];
            gameOver = false;
            clearText();
            appendText(`Welcome, Jackson! You're negotiating a contract for: ${currentProject}\nCustomer: ${currentCustomer.name}\n\nLet's review the draft.`);
            updateScoreboard();
            nextClause();
        }

        function nextClause() {
            if (currentClauseIndex >= selectedClauses.length || gameOver) {
                endGame();
                return;
            }
            const clause = selectedClauses[currentClauseIndex];
            appendText(`\n\nClause: ${clause.name}\nCustomer Redline: ${clause.redline}`);
            showChoices(['Accept', 'Counter', 'Reject']);
        }

        function handleChoice(choice) {
            if (gameOver) return;
            const clause = selectedClauses[currentClauseIndex];
            const option = clause.options[choice.toLowerCase()];
            let adjustedImpact = { ...option }; // Copy impacts

            // Apply choice impacts
            scores.risk += adjustedImpact.risk;
            scores.profit += adjustedImpact.profit;
            scores.relation += adjustedImpact.relation;
            scores.risk = Math.max(0, Math.min(100, scores.risk));
            scores.profit = Math.max(0, Math.min(100, scores.profit));
            scores.relation = Math.max(0, Math.min(100, scores.relation));

            transcript.push(`${clause.name}: ${choice} - ${clause.redline}`);

            // Display explanation and best practice
            appendText(`\nYou chose to ${choice}.\nExplanation: ${option.exp}`);
            appendText(`\nBest Practice: <span class="learn-more" onclick="toggleLearnMore(this)">Click to expand</span><span class="hidden"> - ${option.bp}</span>`);

            // Customer reaction and branching
            let reactionText = '';
            if (choice === 'Accept') {
                reactionText = 'Customer is pleased with your flexibility.';
            } else if (choice === 'Counter') {
                if (Math.random() < currentCustomer.pushbackChance) {
                    reactionText = 'Customer pushes back on your counter.';
                    scores.relation -= 5;
                    // Offer secondary choice
                    appendText(reactionText);
                    showChoices(['Accept Original', 'Insist on Counter']);
                    return; // Wait for secondary choice
                } else {
                    reactionText = 'Customer accepts your counter.';
                }
            } else if (choice === 'Reject') {
                if (Math.random() < currentCustomer.walkAwayChance) {
                    reactionText = 'Customer is offended and walks away!';
                    gameOver = true;
                    scores.relation = 0;
                    appendText(reactionText);
                    endGame();
                    return;
                } else {
                    reactionText = 'Customer grumbles but moves on.';
                    scores.relation -= 10;
                }
            }

            appendText(reactionText);

            // Random event chance (50%)
            if (Math.random() > 0.5) {
                const event = randomEvents[Math.floor(Math.random() * randomEvents.length)];
                appendText(`\nCurveball: ${event.text}`);
                if (event.effect) {
                    scores.risk += event.effect.risk || 0;
                    scores.profit += event.effect.profit || 0;
                    scores.relation += event.effect.relation || 0;
                }
            }

            // Legal Advisor hint (random 30% chance)
            if (Math.random() < 0.3) {
                appendText("\nLegal Advisor: 'Remember, balance is key — don't give away the farm!'");
            }

            updateScoreboard();
            currentClauseIndex++;
            nextClause();
        }

        function endGame() {
            appendText('\n\nNegotiation Complete!');
            appendText('\nFinal Transcript:');
            transcript.forEach(entry => appendText(`- ${entry}`));
            let outcome = outcomes.find(o => o.condition(scores)) || outcomes[0];
            appendText(`\nOutcome: ${outcome.title}\n${outcome.desc}`);
            showChoices(['Restart']);
        }

        // Helper functions
        function updateScoreboard() {
            const sb = document.getElementById('scoreboard');
            sb.innerHTML = `Risk Exposure: ${scores.risk} (lower better) | Profitability: ${scores.profit} (higher better) | Relationship: ${scores.relation} (higher better)`;
        }

        function clearText() {
            document.getElementById('text').innerHTML = '';
        }

        function appendText(text) {
            const textDiv = document.getElementById('text');
            textDiv.innerHTML += text + '\n';
            textDiv.scrollTop = textDiv.scrollHeight;
        }

        function showChoices(choices) {
            const choicesDiv = document.getElementById('choices');
            choicesDiv.innerHTML = '';
            choices.forEach(ch => {
                const btn = document.createElement('button');
                btn.textContent = ch;
                btn.onclick = () => {
                    if (ch === 'Restart') {
                        restartGame();
                    } else if (ch === 'Accept Original') {
                        handleChoice('Accept'); // Treat as accept after pushback
                    } else if (ch === 'Insist on Counter') {
                        handleChoice('Reject'); // Escalate to reject impacts
                    } else {
                        handleChoice(ch);
                    }
                };
                choicesDiv.appendChild(btn);
            });
        }

        function toggleLearnMore(el) {
            const next = el.nextElementSibling;
            next.classList.toggle('hidden');
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Stretch goals notes:
        // - Timer: Add setInterval to decrement time, trigger events if low.
        // - Sandbox: Add mode selection at start, allow custom clause input.
        // - Expand by adding to arrays above.
    </script>
</body>
</html>
